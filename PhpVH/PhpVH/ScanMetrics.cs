using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using PhpVH.LexicalAnalysis;
using PhpVH.CodeCoverage;
using System.Web;
using Components;

namespace PhpVH
{
    public class ScanMetrics
    {
        public static ScanMetrics Default = new ScanMetrics();

        public FileInfo AnnotationFile { get; set; }

        public Dictionary<string, int> AnnotationTable { get; private set; }

        public AnnotationTable IndexTable { get; private set; }

        //public Dictionary<string, List<int>> IndexTable { get; private set; }

        public ScanMetrics()
        {
            AnnotationTable = new Dictionary<string, int>();
            IndexTable = new AnnotationTable();
        }

        public string AnnotateCode(string file, string php, Token[] tokens)
        {
            lock (AnnotationTable)
            {
                AnnotationTable.Add(file, 0);
            }

            lock (AnnotationTable)
            {
                IndexTable.Add(file);
            }

            for (int i = tokens.Length - 1; i >= 0; i--)
            {
                if (tokens[i].TokenType == TokenType.LeftBrace)
                {
                    php = ScanMetrics.Default.AnnotateBlock(file, php,
                        tokens, i, Program.Config.CodeCoverageReport == 1);
                }
            }

            var open = tokens.FirstOrDefault(x => x.TokenType == TokenType.OpenTag);

            if (open.Lexeme != null)
            {
                php = Annotate(file, php, open.Index + open.Lexeme.Length);
            }
            else
            {
                var tmp = Annotate(file, "<?php  ?>", 6);
                php = tmp + php;
            }

            return php;
        }

        public string Annotate(string file, string code, int index)
        {
            int x;

            lock (AnnotationTable)
            {
                x = AnnotationTable[file]++;
            }

            lock (IndexTable)
            {
                IndexTable[file].Add(new Annotation(x, index));
            }

            code = code.Insert(
                index,
                string.Format("\r\nAnnotation(\"{0}_{1}\");\r\n",
                file.Replace("\\", "\\\\"), x));

            return code;
        }

        public string AnnotateBlock(string File, string Code, Token[] Tokens, 
            int TokenIndex, bool FunctionsOnly)
        {
            if (Tokens[TokenIndex - 1].TokenType != TokenType.RightParenthesis &&
                Tokens[TokenIndex - 1].TokenType != TokenType.Keyword)
                return Code;

            for (int i = TokenIndex; i >= 0; i--)
            {
                if (Tokens[i].TokenType == TokenType.Keyword)
                {
                    if (Tokens[i].Lexeme == "switch" || 
                        (FunctionsOnly && Tokens[i].Lexeme != "function"))
                        return Code;

                    break;
                }
            }

            Code = Annotate(File, Code, Tokens[TokenIndex].Index + 1);           

            return Code;
        }

        public void Reset()
        {
            //AnnotationFile.Refresh();

            //if (AnnotationFile.Exists)
            //{
                AnnotationFile.Delete();
            //}

            //_indexes.Clear();
            //_annotationTable.Clear();
        }

        public CodeCoverageTable CalculateCoverage()
        {
            if (!AnnotationFile.Exists)
            {
                return new CodeCoverageTable();
            }

            var entries = new List<string>();

            using (var reader  = new StreamReader(AnnotationFile.OpenRead()))
            {
                string entry;

                while ((entry = reader.ReadLine()) != null)
                {
                    if (!entries.Contains(entry))
                    {
                        entries.Add(entry);
                    }
                }
            }

            var entryTable = new CodeCoverageTable();

            foreach (var entry in entries)
            {
                try
                {
                    var filename = entry.RemoveAtLastIndexOf('_');
                    var id = int.Parse(entry.SubstringAtLastIndexOf('_', 1));
                    IndexTable[filename].GetById(id).HitCount++;

                    if (entryTable.ContainsKey(filename))
                        entryTable[filename]++;
                    else
                        entryTable.Add(filename, 1);
                }
                catch (System.Exception ex) 
                {
#if DEBUG
                    TraceHelper.WriteLineFormat(ex.ToString());
#endif
                }                
            }

            var template = @"<!DOCTYPE html>

<html lang=""en"" xmlns=""http://www.w3.org/1999/xhtml"">
<head>
    <meta charset=""utf-8"" />
    <title></title>
</head>
<body>
    <style type=""text/css"">
        .covered {{
            float: left;
            background-color: green;
        }}
        .uncovered {{
            float: left;
            background-color: red;
        }}
    </style>
    {0}
</body>
</html>";

            //IndexTable
            //    .Select(x => new
            //    {
            //        Filename = x.Filename,
            //        Code = File.ReadAllText(x.Filename + "b"),
            //        Annotations = x.OrderByDescending(y => y.Index).ToArray(),
            //    })
            //    .Select(x => new
            //    {
            //        Code = string.Format(
            //            template,
            //            new StringBuilder(HttpUtility.HtmlEncode(
            //            x.Annotations
            //                .Aggregate(
            //                    new StringBuilder(x.Code),
            //                    (sb, y) => sb.Insert(
            //                        y.Index,
            //                        y.HitCount > 0 ? @"$$$covered$$$" : @"$$$uncovered$$$"))))
            //            .Replace("\r\n", "\n")
            //            .Replace('\r', '\n')
            //            .Replace("\n", "<br />")
            //            .Replace("$$$covered$$$", @"</div><div class=""covered"">")
            //            .Replace("$$$uncovered$$$", @"</div><div class=""uncovered"">")
            //            .Insert(0, @"<div class=""covered"">")
            //            .Append("</div>")
            //            .ToString()),
            //        Filename = x.Filename,
            //    })
            //    .ToArray()
            //    .Iter(x => File.WriteAllText(string.Format(@"c:\temp\{0}.txt", Path.GetFileName(x.Filename)), x.Code));

            
            //    .Select(x => 
            //    {
            //    });
                //.Aggregate(new StringBuilder(), (sb, x) => sb.Append(x.
                //;

            Func<Annotation, bool> wasHit = x => x.HitCount > 0;

            lock (AnnotationTable)
            {
                var hitBlockCount = (decimal)IndexTable
                    .SelectMany(x => x.Where(wasHit))
                    .Count();

                var totalBlockCount = IndexTable
                    .SelectMany(x => x)
                    .Count();

                entryTable.Total = hitBlockCount / totalBlockCount * 100;

                var fileHits = IndexTable
                    .Select(x => new
                    {
                        Filename = x.Filename,
                        HitBlockCount = x.Count(wasHit),
                        TotalBlockCount = x.Count,
                        Coverage = (decimal)x.Count(wasHit) / x.Count * 100,
                    });

                foreach (var key in AnnotationTable.Keys)
                {
                    if (entryTable.ContainsKey(key))
                        entryTable[key] = entryTable[key] / AnnotationTable[key] * 100;
                    else
                        entryTable.Add(key, AnnotationTable[key] == 0 ? 100 : 0);
                }

                foreach (var e in entryTable)
                {
                    var fileCoverage = fileHits.FirstOrDefault(x => x.Filename == e.Key);

                    if (e.Value != fileCoverage.Coverage)
                    {
                        throw new InvalidOperationException();
                    }
                }
            }

            return entryTable;
        }
    }
}
