using Components.MicroScript.Lexer;
using Components.MicroScript.Parser;
using Components.MicroScript.Library;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace Components.MicroScript.Interpreter
{
    public class MicroScriptInterpreter
    {
        private const string _return = "$r";

        private bool _isReturning = false;

        private MicroScriptLoader _loader = new MicroScriptLoader();

        private MicroScriptScope _currentScope = new MicroScriptScope(new MicroScriptObject());

        public MicroScriptInterpreter()
        {
            _currentScope.Variables.Add(
                "__initList",
                WrapValue(new MicroScriptFunction()
                {
                    Args = new[] { "x" },
                    Body = new List<Expression>()
                }));
            //SetApiFunctions(_currentScope.Variables);
        }

        private void SetMember(MicroScriptObject scope, string path, object value)
        {
            var members = path.Split('.');

            var currentObj = scope;

            foreach (var m in members)
            {
                if (!currentObj.ContainsKey(m))
                {
                    currentObj.Add(m, new MicroScriptObject());
                }

                currentObj = currentObj[m];
            }

            currentObj.Value = UnwrapValue(value);
        }

        //private void SetApiFunctions(MicroScriptObject scope)
        //{
        //    _loader.LoadLibrary<StandardLibrary>(scope);
        //}

        private MicroScriptObject CompareDecimals(BinaryOperatorExpression expression, Func<decimal, decimal, bool> equal)
        {
            return WrapValue(
                equal(
                    (decimal)UnwrapValue(InterpretExpression(expression.LeftOperand)),
                    (decimal)UnwrapValue(InterpretExpression(expression.RightOperand))));
        }

        private object InterpretBinaryOperatorExpression(BinaryOperatorExpression expression, bool returnRef = false)
        {
            switch (expression.Operator)
            {
                case MicroScriptTokenType.AdditionOperator:
                    return WrapValue(
                        Add(
                            InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                            InterpretExpression(expression.RightOperand) as MicroScriptObject));

                case MicroScriptTokenType.MinusOperator:
                    return WrapValue(
                        Subtract(
                            InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                            InterpretExpression(expression.RightOperand) as MicroScriptObject));

                case MicroScriptTokenType.MultiplicationOperator:
                    return WrapValue(
                        Multiply(
                            InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                            InterpretExpression(expression.RightOperand) as MicroScriptObject));

                case MicroScriptTokenType.DivisionOperator:
                    return WrapValue(
                        Divide(
                            InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                            InterpretExpression(expression.RightOperand) as MicroScriptObject));

                case MicroScriptTokenType.MemberOperator:
                    var obj = InterpretExpression(expression.LeftOperand) as MicroScriptObject;

                    string key;

                    if (expression.RightOperand is IdentifierExpression)
                    {
                        key = (expression.RightOperand as IdentifierExpression).Identifier;
                    }
                    else if (expression.RightOperand is StringExpression)
                    {
                        key = (string)UnwrapValue(InterpretStringExpression(expression.RightOperand as StringExpression));
                    }
                    else if (expression.RightOperand is DynamicMemberExpression)
                    {
                        var memberExp = expression.RightOperand as DynamicMemberExpression;
                        key = UnwrapValue(InterpretExpression(memberExp.MemberExpression)).ToString();
                    }
                    else
                    {
                        throw new MicroScriptRuntimeException("Unexpected expression {0}", expression.RightOperand);
                    }

                    if (returnRef)
                    {
                        return new MicroScriptRef() { Name = key, Object = obj };
                    }
                    else
                    {
                        MicroScriptObject val;

                        if (!obj.TryGetValue(key, out val))
                        {
                            throw new MicroScriptRuntimeException("Undefined member {0} in expression {1}", key, expression);
                        }

                        return val;
                    }

                case MicroScriptTokenType.AssignmentOperator:
                    var value = InterpretExpression(expression.RightOperand);
                    if (expression.LeftOperand is IdentifierExpression)
                    {
                        var id = (expression.LeftOperand as IdentifierExpression).Identifier;

                        var destObj = InterpretIdentifierExpression(expression.LeftOperand as IdentifierExpression);
                        //var obj = InterpretExpression(expression.LeftOperand) as MicroScriptObject;


                        //if (!_currentScope.Variables.ContainsKey(id))
                        if (destObj == null)
                        {
                            _currentScope.Variables.Add(id, WrapValue(value));
                        }
                        else
                        {
                            destObj.Value = UnwrapValue(value);
                            //_currentScope.Variables[id] = WrapValue(value);
                        }
                    }
                    else
                    {
                        var objRef = InterpretBinaryOperatorExpression(expression.LeftOperand as BinaryOperatorExpression, returnRef = true) as MicroScriptRef;

                        if (objRef.Object == null)
                        {
                            throw new MicroScriptRuntimeException("Undefined variable {0}", expression.LeftOperand);
                        }
                        else if (objRef.Object.ContainsKey(objRef.Name))
                        {
                            objRef.Object[objRef.Name].Value = value;
                        }
                        else
                        {
                            objRef.Object.Add(objRef.Name, WrapValue(value));
                        }
                    }

                    return value;

                case MicroScriptTokenType.EqualityOperator:
                    var left = UnwrapValue(InterpretExpression(expression.LeftOperand));
                    var right = UnwrapValue(InterpretExpression(expression.RightOperand));
                    return WrapValue(left.Equals(right));

                case MicroScriptTokenType.LessThanOperator:
                    return CompareDecimals(expression, (x, y) => x < y);

                case MicroScriptTokenType.LessThanOrEqualOperator:
                    return CompareDecimals(expression, (x, y) => x <= y);

                case MicroScriptTokenType.GreaterThanOperator:
                    return CompareDecimals(expression, (x, y) => x > y);

                case MicroScriptTokenType.GreaterThanOrEqualOperator:
                    return CompareDecimals(expression, (x, y) => x >= y);

                default:
                    throw new MicroScriptRuntimeException("Unknown operator {0} in expression {1}", expression.Operator, expression);
            }
        }

        private MicroScriptObject InterpretObjectExpression(ObjectExpression expression)
        {
            var obj = new MicroScriptObject();

            foreach (var kvp in expression.Pairs)
            {
                var id = (kvp.LeftOperand as IdentifierExpression).Identifier;
                var value = WrapValue(InterpretExpression(kvp.RightOperand));
                obj.Add(id, value);
            }

            return obj;
        }

        private MicroScriptObject InterpretIdentifierExpression(IdentifierExpression expression, MicroScriptScope scope = null)
        {
            if (scope == null)
            {
                scope = _currentScope;
            }

            MicroScriptObject obj;
            if (scope.Variables.TryGetValue(expression.Identifier, out obj))
            {
                return obj;
            }
            else if (scope.Parent != null)
            {
                return InterpretIdentifierExpression(expression, scope.Parent);
            }
            else
            {
                return null;
            }
        }

        private MicroScriptObject InterpretStringExpression(StringExpression expression)
        {
            var s = expression.Value.Substring(1);
            return WrapValue(s.Remove(s.Length - 1));
        }

        private object UnwrapValue(object obj)
        {
            MicroScriptObject microScriptObj;

            return (microScriptObj = obj as MicroScriptObject) != null ? microScriptObj.Value : obj;
        }

        private MicroScriptObject WrapValue(object obj)
        {
            MicroScriptObject microScriptObj;

            return (microScriptObj = obj as MicroScriptObject) != null ? microScriptObj : new MicroScriptObject(obj);
        }

        private MicroScriptObject CallFunction(MicroScriptFunction func2, IEnumerable<MicroScriptObject> parms)
        {
            var functionScope = new MicroScriptScope(new MicroScriptObject(), func2.ParentScope);

            //SetApiFunctions(functionScope.Variables);

            var i = 0;
            foreach (var arg in parms)
            {
                if (func2.Args.Length == i)
                {
                    break;
                }

                functionScope.Variables.Add(func2.Args[i++], arg);
            }

            var lastScope = _currentScope;
            _currentScope = functionScope;

            Interpret(func2.Body);

            var retVal = GetReturnValue();

            _currentScope = lastScope;

            return retVal;
        }

        private MicroScriptObject GetReturnValue()
        {
            MicroScriptObject retVal = null;

            _currentScope.Variables.TryGetValue(_return, out retVal);

            return retVal;
        }

        private void SetReturnValue(MicroScriptObject obj)
        {
            _currentScope.Variables.Add(_return, obj);
        }

        private object InterpretCallExpression(CallExpression expression)
        {
            var value = InterpretExpression(expression.FunctionExpression);

            object funcExp = UnwrapValue(value);

            var func = funcExp as MicroScriptInteropFunction;

            if (func == null)
            {
                var func2 = funcExp as MicroScriptFunction;

                if (func2 == null)
                {
                    throw new MicroScriptRuntimeException("Could not find function {0}", expression.FunctionExpression);
                }

                return CallFunction(func2, expression.Args.Select(x => WrapValue(InterpretExpression(x))));                
            }
            else
            {
                var args = expression.Args
                    .Select(x =>
                    {
                        return UnwrapValue(InterpretExpression(x));
                    })
                    .ToArray();

                return WrapValue(func.Invoke(args));
            }
        }

        private MicroScriptFunction InterpretFunctionExpression(FunctionExpression expression)
        {
            return new MicroScriptFunction()
            {
                Args = expression.Args.Select(x => x.Identifier).ToArray(),
                Body = expression.Body,
                ParentScope = _currentScope,
            };
        }

        private MicroScriptObject InterpretArrayExpression(ArrayExpression expression)
        {
            var list = WrapValue(expression.Elements.Select(InterpretExpression).Cast<MicroScriptObject>().ToList());
            var init = InterpretIdentifierExpression(new IdentifierExpression("__initList")).Value as MicroScriptFunction;
            CallFunction(init, new[] { list });
            return list;
        }

        private MicroScriptRuntimeException CreateUnaryOperatorException(UnaryOperatorExpression expression)
        {
            throw new MicroScriptRuntimeException("Unknown operator {0} in expression {1}", expression.Operator, expression);
        }

        private object InterpretUnaryOperatorExpression(UnaryOperatorExpression expression)
        {
            if (!expression.IsPostfix)
            {
                switch (expression.Operator)
                {
                    case MicroScriptTokenType.retKeyword:
                        SetReturnValue(WrapValue(InterpretExpression(expression.Operand)));
                        _isReturning = true;
                        return null;

                    case MicroScriptTokenType.NotOperator:
                        return WrapValue(!(bool)UnwrapValue(InterpretExpression(expression.Operand) as MicroScriptObject));

                    default:
                        throw CreateUnaryOperatorException(expression);
                }
            }
            else
            {
                switch (expression.Operator)
                {
                    case MicroScriptTokenType.IncrementOperator:
                        var obj = InterpretExpression(expression.Operand) as MicroScriptObject;
                        obj.Value = ((decimal)obj.Value) + 1;
                        return obj;

                    default:
                        throw CreateUnaryOperatorException(expression);
                }
            }
        }

        private MicroScriptObject InterpretBooleanExpression(BooleanExpression expression)
        {
            return new MicroScriptObject(expression.Value);
        }

        private void InterpretChild(List<Expression> block)
        {
            CreateChildScope();
            Interpret(block, false);
            DestroyChildScope(true);
        }

        private MicroScriptObject InterpretIfExpression(IfExpression expression)
        {
            if ((bool)UnwrapValue(InterpretExpression(expression.Condition)))
            {
                InterpretChild(expression.Body);
            }
            else if (expression.ElseBody != null)
            {
                InterpretChild(expression.ElseBody);
            }
            return null;
        }

        public MicroScriptObject InterpretNumberExpression(NumberExpression expression)
        {
            return WrapValue(expression.Value);
        }

        public MicroScriptObject Add(MicroScriptObject x, MicroScriptObject y)
        {
            if (x.Value is decimal && y.Value is Decimal)
            {
                return WrapValue((decimal)x.Value + (decimal)y.Value);
            }
            else
            {
                return WrapValue(Convert.ToString(x.Value) + Convert.ToString(y.Value));
            }
        }

        public MicroScriptObject Subtract(MicroScriptObject x, MicroScriptObject y)
        {
            return WrapValue(((decimal)x.Value) - (decimal)y.Value);
        }

        public MicroScriptObject Multiply(MicroScriptObject x, MicroScriptObject y)
        {
            return WrapValue(((decimal)x.Value) * (decimal)y.Value);
        }

        public MicroScriptObject Divide(MicroScriptObject x, MicroScriptObject y)
        {
            return WrapValue(((decimal)x.Value) / (decimal)y.Value);
        }

        private MicroScriptObject InterpretArrayAccessExpression(ArrayAccessExpression expression)
        {
            var array = UnwrapValue(InterpretExpression(expression.ArrayExpression)) as List<MicroScriptObject>;
            var index = Convert.ToInt32(UnwrapValue(InterpretExpression(expression.KeyExpression)));
            return WrapValue(array[(int)index]);
        }

        private void CreateChildScope()
        {
            _currentScope = new MicroScriptScope(new MicroScriptObject(), _currentScope);
        }

        private bool DestroyChildScope(bool bubbleReturnValue = false)
        {
            if (bubbleReturnValue)
            {
                var ret = GetReturnValue();
                _currentScope = _currentScope.Parent;

                if (ret != null)
                {
                    SetReturnValue(ret);

                    return true;
                }
            }
            else
            {
                _currentScope = _currentScope.Parent;
            }

            return false;
        }

        private MicroScriptObject InterpretForExpression(ForExpression expression)
        {
            var collection = InterpretExpression(expression.Collection) as MicroScriptObject;
            var elements = collection.Value as List<MicroScriptObject>;
            var elementId = (expression.Element as IdentifierExpression).Identifier;

            foreach (var element in elements)
            {
                CreateChildScope();
                _currentScope.Variables.Add(elementId, WrapValue(element));
                Interpret(expression.Body, false);
                
                if (DestroyChildScope(true))
                {
                    break;                    
                }
            }
            return null;
        }

        private MicroScriptObject InterpretLoadScriptExpression(LoadScriptExpression expression)
        {
            var file = UnwrapValue(InterpretExpression(expression.FileExpression)) as string;

            if (file == null)
            {
                throw new MicroScriptRuntimeException("Cannot load script {0}", expression.FileExpression); 
            }

            if (File.Exists(file))
            {
                var script = File.ReadAllText(file);

                Interpret(script);
            }
            else
            {
                throw new MicroScriptRuntimeException("Cannot find script {0}", file);
            }

            return null;
        }

        private MicroScriptObject InterpretLoadLibraryExpression(LoadLibraryExpression expression)
        {
            var library = UnwrapValue(InterpretExpression(expression.LibraryExpression)) as string;

            var t = Assembly.GetExecutingAssembly().GetType(library);

            _loader.LoadLibrary(t, _currentScope.Variables);

            if (library == null)
            {
                throw new MicroScriptRuntimeException("Cannot load script {0}", expression.LibraryExpression);
            }

            return null;
        }

        private object InterpretExpression(Expression expression)
        {
            if (expression is BinaryOperatorExpression)
            {
                return InterpretBinaryOperatorExpression(expression as BinaryOperatorExpression);
            }
            else if (expression is ObjectExpression)
            {
                return InterpretObjectExpression(expression as ObjectExpression);
            }
            else if (expression is StringExpression)
            {
                return InterpretStringExpression(expression as StringExpression);
            }
            else if (expression is NumberExpression)
            {
                return InterpretNumberExpression(expression as NumberExpression);
            }
            else if (expression is CallExpression)
            {
                return InterpretCallExpression(expression as CallExpression);
            }
            else if (expression is IdentifierExpression)
            {
                return InterpretIdentifierExpression(expression as IdentifierExpression);
            }
            else if (expression is FunctionExpression)
            {
                return InterpretFunctionExpression(expression as FunctionExpression);
            }
            else if (expression is ArrayExpression)
            {
                return InterpretArrayExpression(expression as ArrayExpression);
            }
            else if (expression is UnaryOperatorExpression)
            {
                return InterpretUnaryOperatorExpression(expression as UnaryOperatorExpression);
            }
            else if (expression is BooleanExpression)
            {
                return InterpretBooleanExpression(expression as BooleanExpression);
            }
            else if (expression is IfExpression)
            {
                return InterpretIfExpression(expression as IfExpression);
            }
            else if (expression is ArrayAccessExpression)
            {
                return InterpretArrayAccessExpression(expression as ArrayAccessExpression);
            }
            else if (expression is ForExpression)
            {
                return InterpretForExpression(expression as ForExpression);
            }
            else if (expression is LoadScriptExpression)
            {
                return InterpretLoadScriptExpression(expression as LoadScriptExpression);
            }
            else if (expression is LoadLibraryExpression)
            {
                return InterpretLoadLibraryExpression(expression as LoadLibraryExpression);
            }
            else
            {
                throw new MicroScriptRuntimeException("Unexpected expression {0}", expression);
            }
        }

        public void Interpret(List<Expression> expressions, bool resetIsReturning = true)
        {
            foreach (var expression in expressions)
            {
                InterpretExpression(expression);

                if (_isReturning)
                {
                    if (resetIsReturning)
                    {
                        _isReturning = false;
                    }

                    break;
                }
            }
        }

        public void Interpret(string code)
        {
            var lexer = new MicroScriptLexer(code);
            var tokens = lexer
                .GetTokens()
                .Where(x =>
                    x.TokenType != MicroScriptTokenType.WhiteSpace &&
                    x.TokenType != MicroScriptTokenType.Comment);

            var parser = new MicroScriptParser(tokens.ToArray());
            var ast = parser.Parse();
            Interpret(ast);
        }
    }
}
