using Components.MicroScript.Lexer;
using Components.MicroScript.Parser;
using Components.MicroScript.Library;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using System.Collections;

namespace Components.MicroScript.Interpreter
{
    public class MicroScriptInterpreter
    {
        private const string _return = "$r";

        private bool _isReturning = false;

        private MicroScriptLoader _loader;

        private MicroScriptScope _currentScope = new MicroScriptScope(new MicroScriptObject());

        public MicroScriptScope CurrentScope
        {
            get { return _currentScope; }
        }

        private OperatorHelper _opHelper;

        public MicroScriptInterpreter()
        {
            _opHelper = new OperatorHelper(CallInitFunction);
            _loader = new MicroScriptLoader(this);

            _currentScope.Variables.Add(
                "__initList",
                ValueHelper.Wrap(new MicroScriptFunction()
                {
                    Args = new[] { "x" },
                    Body = new List<Expression>()
                }));

            _currentScope.Variables.Add(
                "__initString",
                ValueHelper.Wrap(new MicroScriptFunction()
                {
                    Args = new[] { "x" },
                    Body = new List<Expression>()
                }));
        }

        private MicroScriptObject CompareDecimals(BinaryOperatorExpression expression, Func<decimal, decimal, bool> equal)
        {
            return ValueHelper.Wrap(
                equal(
                    (decimal)ValueHelper.Unwrap(InterpretExpression(expression.LeftOperand)),
                    (decimal)ValueHelper.Unwrap(InterpretExpression(expression.RightOperand))));
        }

        private MicroScriptObject InterpretAndExpression(BinaryOperatorExpression expression)
        {
            var left = (bool)ValueHelper.Unwrap(InterpretExpression(expression.LeftOperand));
            var right = (bool)ValueHelper.Unwrap(InterpretExpression(expression.RightOperand));
            return ValueHelper.Wrap(left && right);
        }

        private MicroScriptObject InterpretEqualityExpression(BinaryOperatorExpression expression)
        {
            var left = ValueHelper.Unwrap(InterpretExpression(expression.LeftOperand));
            var right = ValueHelper.Unwrap(InterpretExpression(expression.RightOperand));
            var val = left.Equals(right);

            if (expression.Operator == MicroScriptTokenType.NotEqualOperator)
            {
                val = !val;
            }

            return ValueHelper.Wrap(val); 
        }

        private object InterpretMemberExpression(BinaryOperatorExpression expression, bool returnRef = false)
        {
            var obj = InterpretExpression(expression.LeftOperand) as MicroScriptObject;

            string key;

            if (expression.RightOperand is IdentifierExpression)
            {
                key = (expression.RightOperand as IdentifierExpression).Identifier;
            }
            else if (expression.RightOperand is StringExpression)
            {
                key = (string)ValueHelper.Unwrap(InterpretStringExpression(expression.RightOperand as StringExpression));
            }
            else if (expression.RightOperand is DynamicMemberExpression)
            {
                var memberExp = expression.RightOperand as DynamicMemberExpression;
                key = ValueHelper.Unwrap(InterpretExpression(memberExp.MemberExpression)).ToString();
            }
            else
            {
                throw new MicroScriptRuntimeException("Unexpected expression {0}", expression.RightOperand);
            }

            if (returnRef)
            {
                return new MicroScriptRef() { Name = key, Object = obj };
            }
            else
            {
                MicroScriptObject val;

                if (!obj.TryGetValue(key, out val))
                {
                    throw new MicroScriptRuntimeException("Undefined member {0} in expression {1}", key, expression);
                }

                return val;
            }
        }

        private object InterpetAssignmentExpression(BinaryOperatorExpression expression, bool returnRef = false)
        {
            var value = InterpretExpression(expression.RightOperand);
            if (expression.LeftOperand is IdentifierExpression)
            {
                var id = (expression.LeftOperand as IdentifierExpression).Identifier;
                var destObj = InterpretIdentifierExpression(expression.LeftOperand as IdentifierExpression);

                if (destObj == null)
                {
                    _currentScope.Variables.Add(id, ValueHelper.Wrap(value));
                }
                else
                {
                    destObj.Value = ValueHelper.Unwrap(value);
                }
            }
            else
            {
                var objRef = InterpretBinaryOperatorExpression(expression.LeftOperand as BinaryOperatorExpression, true) as MicroScriptRef;

                if (objRef.Object == null)
                {
                    throw new MicroScriptRuntimeException("Undefined variable {0}", expression.LeftOperand);
                }
                else if (objRef.Object.ContainsKey(objRef.Name))
                {
                    objRef.Object[objRef.Name].Value = value;
                }
                else
                {
                    objRef.Object.Add(objRef.Name, ValueHelper.Wrap(value));
                }
            }

            return value;
        }

        private object InterpretBinaryOperatorExpression(BinaryOperatorExpression expression, bool returnRef = false)
        {
            switch (expression.Operator)
            {
                case MicroScriptTokenType.AdditionOperator:
                    return _opHelper.Add(
                        InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                        InterpretExpression(expression.RightOperand) as MicroScriptObject);

                case MicroScriptTokenType.MinusOperator:
                    return _opHelper.Subtract(
                        InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                        InterpretExpression(expression.RightOperand) as MicroScriptObject);

                case MicroScriptTokenType.MultiplicationOperator:
                    return _opHelper.Multiply(
                        InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                        InterpretExpression(expression.RightOperand) as MicroScriptObject);

                case MicroScriptTokenType.DivisionOperator:
                    return _opHelper.Divide(
                        InterpretExpression(expression.LeftOperand) as MicroScriptObject,
                        InterpretExpression(expression.RightOperand) as MicroScriptObject);

                case MicroScriptTokenType.MemberOperator:
                    return InterpretMemberExpression(expression, returnRef);                    

                case MicroScriptTokenType.AssignmentOperator:
                    return InterpetAssignmentExpression(expression, returnRef);

                case MicroScriptTokenType.NotEqualOperator:
                case MicroScriptTokenType.EqualityOperator:
                    return InterpretEqualityExpression(expression);

                case MicroScriptTokenType.LessThanOperator:
                    return CompareDecimals(expression, (x, y) => x < y);

                case MicroScriptTokenType.LessThanOrEqualOperator:
                    return CompareDecimals(expression, (x, y) => x <= y);

                case MicroScriptTokenType.GreaterThanOperator:
                    return CompareDecimals(expression, (x, y) => x > y);

                case MicroScriptTokenType.GreaterThanOrEqualOperator:
                    return CompareDecimals(expression, (x, y) => x >= y);

                case MicroScriptTokenType.AndOperator:
                    return InterpretAndExpression(expression);

                default:
                    throw new MicroScriptRuntimeException("Unknown operator {0} in expression {1}", expression.Operator, expression);
            }
        }

        private MicroScriptObject InterpretObjectExpression(ObjectExpression expression)
        {
            var obj = new MicroScriptObject();

            foreach (var kvp in expression.Pairs)
            {
                var id = (kvp.LeftOperand as IdentifierExpression).Identifier;
                var value = ValueHelper.Wrap(InterpretExpression(kvp.RightOperand));
                obj.Add(id, value);
            }

            return obj;
        }

        private MicroScriptObject InterpretIdentifierExpression(IdentifierExpression expression, MicroScriptScope scope = null)
        {
            if (scope == null)
            {
                scope = _currentScope;
            }

            MicroScriptObject obj;
            if (scope.Variables.TryGetValue(expression.Identifier, out obj))
            {
                return obj;
            }
            else if (scope.Parent != null)
            {
                return InterpretIdentifierExpression(expression, scope.Parent);
            }
            else
            {
                return null;
            }
        }

        private MicroScriptObject InterpretStringExpression(StringExpression expression)
        {
            var delim = expression.Value[0];
            var s = expression.Value.Substring(1);
            s = s.Remove(s.Length - 1);
            var sb = new StringBuilder();

            var state = 0;

            for (int i = 0; i < s.Length; i++)
            {
                var c = s[i];

                switch (state)
                {
                    case 0:
                        switch (c)
                        {
                            case '\\':
                                state = 1;
                                break;
                            
                            default:
                                sb.Append(c);
                                break;
                        }
                        break;

                    case 1:
                        switch (c)
                        {
                            case '\\':
                                sb.Append('\\');
                                state = 0;
                                break;

                            case 'r':
                                sb.Append('\r');
                                state = 0;
                                break;

                            case 'n':
                                sb.Append('\n');
                                state = 0;
                                break;

                            case '"':
                            case '\'':
                                if (c != delim)
                                {
                                    throw new InvalidOperationException();
                                }

                                sb.Append(delim);
                                state = 0;
                                break;

                            default:
                                throw new InvalidOperationException("Invalid escape sequence");
                        }
                        break;
                }
            }

            var obj = ValueHelper.Wrap(sb.ToString());

            CallInitFunction(obj);

            return obj;
        }

        private MicroScriptObject CallFunction(MicroScriptFunction func2, IEnumerable<MicroScriptObject> parms)
        {
            var functionScope = new MicroScriptScope(new MicroScriptObject(), func2.ParentScope);

            var i = 0;
            foreach (var arg in parms)
            {
                if (func2.Args.Length == i)
                {
                    break;
                }

                functionScope.Variables.Add(func2.Args[i++], arg);
            }

            var lastScope = _currentScope;
            _currentScope = functionScope;

            Interpret(func2.Body);

            var retVal = GetReturnValue();

            _currentScope = lastScope;

            return retVal;
        }

        public MicroScriptObject GetReturnValue()
        {
            MicroScriptObject retVal = null;

            _currentScope.Variables.TryGetValue(_return, out retVal);

            return retVal;
        }

        private void SetReturnValue(MicroScriptObject obj)
        {
            _currentScope.Variables.Add(_return, obj);
        }

        private object InterpretCallExpression(CallExpression expression)
        {
            var value = InterpretExpression(expression.FunctionExpression);

            object funcExp = ValueHelper.Unwrap(value);

            var func = funcExp as MicroScriptInteropFunction;

            if (func == null)
            {
                var func2 = funcExp as MicroScriptFunction;

                if (func2 == null)
                {
                    throw new MicroScriptRuntimeException("Could not find function {0}", expression.FunctionExpression);
                }

                return CallFunction(func2, expression.Args.Select(x => ValueHelper.Wrap(InterpretExpression(x))));
            }
            else
            {
                var args = expression.Args
                    .Select(x =>
                    {
                        return ValueHelper.Unwrap(InterpretExpression(x));
                    })
                    .ToArray();

                var retVal = ValueHelper.Wrap(func.Invoke(args));

                if (retVal.Value is List<MicroScriptObject> ||
                    retVal.Value is string)
                {
                    CallInitFunction(retVal);
                    //InitList(retVal);
                }

                return retVal;
            }
        }

        private MicroScriptFunction InterpretFunctionExpression(FunctionExpression expression)
        {
            return new MicroScriptFunction()
            {
                Args = expression.Args.Select(x => x.Identifier).ToArray(),
                Body = expression.Body,
                ParentScope = _currentScope,
            };
        }

        private MicroScriptFunction GetInitFunction(string name)
        {
            return InterpretIdentifierExpression(new IdentifierExpression("__init" + name)).Value as MicroScriptFunction;
        }

        private MicroScriptObject CallInitFunction(MicroScriptObject obj)
        {
            string name = "List";

            if (obj.Value is List<MicroScriptObject>)
            {
                name = "List";
            }
            else if (obj.Value is string)
            {
                name = "String";
            }
            else
            {
                return obj;
            }

            CallFunction(GetInitFunction(name), new[] { obj });

            return obj;
        }

        private MicroScriptObject InterpretArrayExpression(ArrayExpression expression)
        {
            var list = ValueHelper.Wrap(expression.Elements.Select(InterpretExpression).OfType<MicroScriptObject>().ToList());
            CallInitFunction(list);
            //InitList(list);
            //CallFunction(GetInitList(), new[] { list });
            return list;
        }

        private MicroScriptRuntimeException CreateUnaryOperatorException(UnaryOperatorExpression expression)
        {
            throw new MicroScriptRuntimeException("Unknown operator {0} in expression {1}", expression.Operator, expression);
        }

        private object InterpretUnaryOperatorExpression(UnaryOperatorExpression expression)
        {
            if (!expression.IsPostfix)
            {
                switch (expression.Operator)
                {
                    case MicroScriptTokenType.retKeyword:
                        SetReturnValue(ValueHelper.Wrap(InterpretExpression(expression.Operand)));
                        _isReturning = true;
                        return null;

                    case MicroScriptTokenType.NotOperator:
                        return ValueHelper.Wrap(!(bool)ValueHelper.Unwrap(InterpretExpression(expression.Operand) as MicroScriptObject));

                    default:
                        throw CreateUnaryOperatorException(expression);
                }
            }
            else
            {
                switch (expression.Operator)
                {
                    case MicroScriptTokenType.IncrementOperator:
                        var obj = InterpretExpression(expression.Operand) as MicroScriptObject;
                        obj.Value = ((decimal)obj.Value) + 1;
                        return obj;

                    case MicroScriptTokenType.ExistsOperator:
                        if (expression.Operand is IdentifierExpression)
                        {
                            return ValueHelper.Wrap(InterpretIdentifierExpression(expression.Operand as IdentifierExpression) != null);
                        }
                        else if (expression.Operand is BinaryOperatorExpression)
                        {
                            var objRef = InterpretBinaryOperatorExpression(expression.Operand as BinaryOperatorExpression, true) as MicroScriptRef;
                            return ValueHelper.Wrap(objRef.Object.ContainsKey(objRef.Name));
                        }
                        else
                        {
                            throw new MicroScriptRuntimeException("Unknown ? operand");
                        }
                    //var obj = InterpretExpression(

                    default:
                        throw CreateUnaryOperatorException(expression);
                }
            }
        }

        private MicroScriptObject InterpretBooleanExpression(BooleanExpression expression)
        {
            return new MicroScriptObject(expression.Value);
        }

        private void InterpretChild(List<Expression> block)
        {
            CreateChildScope();
            Interpret(block, false);
            DestroyChildScope(true);
        }

        private MicroScriptObject InterpretIfExpression(IfExpression expression)
        {
            if ((bool)ValueHelper.Unwrap(InterpretExpression(expression.Condition)))
            {
                InterpretChild(expression.Body);
            }
            else if (expression.ElseBody != null)
            {
                InterpretChild(expression.ElseBody);
            }
            return null;
        }

        public MicroScriptObject InterpretNumberExpression(NumberExpression expression)
        {
            return ValueHelper.Wrap(expression.Value);
        }

        private MicroScriptObject InterpretArrayAccessExpression(ArrayAccessExpression expression)
        {
            var array = ValueHelper.Unwrap(InterpretExpression(expression.ArrayExpression)) as List<MicroScriptObject>;
            var index = Convert.ToInt32(ValueHelper.Unwrap(InterpretExpression(expression.KeyExpression)));
            return ValueHelper.Wrap(array[(int)index]);
        }

        private void CreateChildScope()
        {
            _currentScope = new MicroScriptScope(new MicroScriptObject(), _currentScope);
        }

        private bool DestroyChildScope(bool bubbleReturnValue = false)
        {
            if (bubbleReturnValue)
            {
                var ret = GetReturnValue();
                _currentScope = _currentScope.Parent;

                if (ret != null)
                {
                    SetReturnValue(ret);

                    return true;
                }
            }
            else
            {
                _currentScope = _currentScope.Parent;
            }

            return false;
        }

        private MicroScriptObject InterpretForExpression(ForExpression expression)
        {
            var collection = InterpretExpression(expression.Collection) as MicroScriptObject;

            IEnumerable elements;

            if (collection.Value is List<MicroScriptObject>)
            {
                elements = collection.Value as IEnumerable;
            }


            elements = collection.Value as List<MicroScriptObject>;
            var elementId = (expression.Element as IdentifierExpression).Identifier;

            foreach (var element in elements)
            {
                CreateChildScope();
                _currentScope.Variables.Add(elementId, ValueHelper.Wrap(element));
                Interpret(expression.Body, false);

                if (DestroyChildScope(true))
                {
                    break;
                }
            }
            return null;
        }

        private MicroScriptObject InterpretLoadScriptExpression(LoadScriptExpression expression)
        {
            var file = ValueHelper.Unwrap(InterpretExpression(expression.FileExpression)) as string;

            if (file == null)
            {
                throw new MicroScriptRuntimeException("Cannot load script {0}", expression.FileExpression);
            }

            if (File.Exists(file))
            {
                var script = File.ReadAllText(file);

                Interpret(script);
            }
            else
            {
                throw new MicroScriptRuntimeException("Cannot find script {0}", file);
            }

            return null;
        }

        private MicroScriptObject InterpretLoadLibraryExpression(LoadLibraryExpression expression)
        {
            var library = ValueHelper.Unwrap(InterpretExpression(expression.LibraryExpression)) as string;

            var t = Assembly.GetExecutingAssembly().GetType(library);

            _loader.LoadLibrary(t, _currentScope.Variables);

            if (library == null)
            {
                throw new MicroScriptRuntimeException("Cannot load script {0}", expression.LibraryExpression);
            }

            return null;
        }

        private object InterpretExpression(Expression expression)
        {
            if (expression is BinaryOperatorExpression)
            {
                return InterpretBinaryOperatorExpression(expression as BinaryOperatorExpression);
            }
            else if (expression is ObjectExpression)
            {
                return InterpretObjectExpression(expression as ObjectExpression);
            }
            else if (expression is StringExpression)
            {
                return InterpretStringExpression(expression as StringExpression);
            }
            else if (expression is NumberExpression)
            {
                return InterpretNumberExpression(expression as NumberExpression);
            }
            else if (expression is CallExpression)
            {
                return InterpretCallExpression(expression as CallExpression);
            }
            else if (expression is IdentifierExpression)
            {
                return InterpretIdentifierExpression(expression as IdentifierExpression);
            }
            else if (expression is FunctionExpression)
            {
                return InterpretFunctionExpression(expression as FunctionExpression);
            }
            else if (expression is ArrayExpression)
            {
                return InterpretArrayExpression(expression as ArrayExpression);
            }
            else if (expression is UnaryOperatorExpression)
            {
                return InterpretUnaryOperatorExpression(expression as UnaryOperatorExpression);
            }
            else if (expression is BooleanExpression)
            {
                return InterpretBooleanExpression(expression as BooleanExpression);
            }
            else if (expression is IfExpression)
            {
                return InterpretIfExpression(expression as IfExpression);
            }
            else if (expression is ArrayAccessExpression)
            {
                return InterpretArrayAccessExpression(expression as ArrayAccessExpression);
            }
            else if (expression is ForExpression)
            {
                return InterpretForExpression(expression as ForExpression);
            }
            else if (expression is LoadScriptExpression)
            {
                return InterpretLoadScriptExpression(expression as LoadScriptExpression);
            }
            else if (expression is LoadLibraryExpression)
            {
                return InterpretLoadLibraryExpression(expression as LoadLibraryExpression);
            }
            else
            {
                throw new MicroScriptRuntimeException("Unexpected expression {0}", expression);
            }
        }

        public void Interpret(List<Expression> expressions, bool resetIsReturning = true)
        {
            foreach (var expression in expressions)
            {
                InterpretExpression(expression);

                if (_isReturning)
                {
                    if (resetIsReturning)
                    {
                        _isReturning = false;
                    }

                    break;
                }
            }
        }

        public void Interpret(string code)
        {
            var lexer = new MicroScriptLexer(code);
            var tokens = lexer
                .GetTokens()
                .Where(x =>
                    x.TokenType != MicroScriptTokenType.WhiteSpace &&
                    x.TokenType != MicroScriptTokenType.Comment);

            var parser = new MicroScriptParser(tokens.ToArray());
            var ast = parser.Parse();
            Interpret(ast);
        }

        public void InterpretFile(string filename)
        {
            Interpret(File.ReadAllText(filename));
        }
    }
}
