using Components.MicroScript.Lexer;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Components.MicroScript.Parser
{
    public class MicroScriptParser
    {
        private MicroScriptToken[] _tokens;

        private int _tokenIndex = -1;

        private MicroScriptToken _currentToken;

        public MicroScriptParser(MicroScriptToken[] tokens)
        {
            _tokens = tokens;
        }

        [System.Diagnostics.DebuggerStepThrough]
        private bool Match(MicroScriptTokenType tokenType)
        {
            if (_currentToken.TokenType == tokenType)
            {
                NextToken();
                return true;
            }
            else
            {
                throw new MicroScriptParserException(_currentToken);
            }
        }

        [System.Diagnostics.DebuggerStepThrough]
        private bool NextToken()
        {
            _tokenIndex++;

            if (_tokenIndex < _tokens.Length)
            {
                _currentToken = _tokens[_tokenIndex];
                return true;
            }
            else
            {
                _currentToken = default(MicroScriptToken);
                return false;
            }
        }

        private FunctionExpression ParseFunctionExpression()
        {
            var exp = new FunctionExpression()
            {
                Args = new List<IdentifierExpression>()
            };

            NextToken();

            Match(MicroScriptTokenType.LeftParenthesis);

            if (_currentToken.TokenType != MicroScriptTokenType.RightParenthesis)
            {
                while (true)
                {
                    if (_currentToken.TokenType == MicroScriptTokenType.Identifier)
                    {
                        exp.Args.Add(ParseIdentifierExpression() as IdentifierExpression);

                        if (_currentToken.TokenType == MicroScriptTokenType.Comma)
                        {
                            NextToken();
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        throw new MicroScriptParserException(_currentToken);
                    }
                }
            }

            Match(MicroScriptTokenType.RightParenthesis);

            var isSingleLine = _currentToken.TokenType != MicroScriptTokenType.LeftBrace;

            var body = ParseBlock(false);

            if (isSingleLine)
            {
                exp.Body = new List<Expression> { new UnaryOperatorExpression(MicroScriptTokenType.retKeyword, body[0]) };
            }
            else
            {
                exp.Body = body;
            }

            return exp;
        }

        private BinaryOperatorExpression ParseKeyValuePairExpression()
        {
            var id = new IdentifierExpression(_currentToken.Lexeme);
            NextToken();
            Match(MicroScriptTokenType.ColonOperator);
            var exp = ParseExpression();
            return new BinaryOperatorExpression(id, MicroScriptTokenType.ColonOperator, exp);
        }

        private StringExpression ParseStringExpression()
        {
            var exp = new StringExpression(_currentToken.Lexeme);
            NextToken();
            return exp;
        }

        private ObjectExpression ParseObjectExpression()
        {
            NextToken();

            var inNode = true;

            var childNodes = new List<BinaryOperatorExpression>();

            while (inNode)
            {
                switch (_currentToken.TokenType)
                {
                    case MicroScriptTokenType.Identifier:
                        childNodes.Add(ParseKeyValuePairExpression());

                        switch (_currentToken.TokenType)
                        {
                            case MicroScriptTokenType.Comma:
                                NextToken();
                                break;

                            case MicroScriptTokenType.RightBrace:
                                NextToken();
                                inNode = false;
                                break;

                            default:
                                throw new MicroScriptParserException(_currentToken);
                        }

                        break;

                    case MicroScriptTokenType.RightBrace: // empty object
                        NextToken();
                        inNode = false;
                        break;

                    default:
                        throw new MicroScriptParserException(_currentToken);
                }
            }

            return new ObjectExpression() { Pairs = childNodes };
        }

        public NumberExpression ParseNumberExpression()
        {
            var exp = new NumberExpression(decimal.Parse(_currentToken.Lexeme));
            NextToken();
            return exp;
        }

        public ArrayExpression ParseArrayExpression()
        {
            NextToken();

            var inNode = true;

            var childNodes = new List<Expression>();

            if (_currentToken.TokenType != MicroScriptTokenType.RightBracket)
            {
                while (inNode)
                {
                    childNodes.Add(ParseExpression());

                    switch (_currentToken.TokenType)
                    {
                        case MicroScriptTokenType.Comma:
                            NextToken();
                            break;

                        case MicroScriptTokenType.RightBracket:
                            NextToken();
                            inNode = false;
                            break;

                        default:
                            throw new MicroScriptParserException(_currentToken);
                    }
                }
            }
            else
            {
                NextToken();
            }

            return new ArrayExpression() { Elements = childNodes };
        }

        private Expression ParseIdentifierExpression()
        {
            var exp = new IdentifierExpression(_currentToken.Lexeme);
            NextToken();
            return exp;
        }

        public Expression ParseExpression()
        {
            return ParseAssignment();
        }

        private Expression ParseAssignment()
        {
            var additionExpression = ParseLogicalExpression();

            if (_currentToken.TokenType == MicroScriptTokenType.AssignmentOperator)
            {
                var op = _currentToken.TokenType;
                NextToken();
                return new BinaryOperatorExpression(additionExpression, op, ParseAssignment());
            }
            else
            {
                return additionExpression;
            }
        }

        private Expression ParseLogicalExpression()
        {
            Expression term = ParseComparisonExpression();

            while (_currentToken.TokenType == MicroScriptTokenType.AndOperator ||
                _currentToken.TokenType == MicroScriptTokenType.OrOperator)
            {
                var t = _currentToken.TokenType;

                NextToken();

                term = ParseCall(new BinaryOperatorExpression(term, t, ParseComparisonExpression()));
            }

            return term;
        }

        private Expression ParseComparisonExpression()
        {
            var term = ParsePostfixUnaryOperationExpression();

            if (_currentToken.TokenType == MicroScriptTokenType.EqualityOperator ||
                _currentToken.TokenType == MicroScriptTokenType.NotEqualOperator ||
                _currentToken.TokenType == MicroScriptTokenType.LessThanOperator ||
                _currentToken.TokenType == MicroScriptTokenType.LessThanOrEqualOperator ||
                _currentToken.TokenType == MicroScriptTokenType.GreaterThanOperator ||
                _currentToken.TokenType == MicroScriptTokenType.GreaterThanOrEqualOperator)
            {
                var op = _currentToken.TokenType;
                NextToken();
                return new BinaryOperatorExpression(term, op, ParseComparisonExpression());
            }
            else
            {
                return term;
            }
        }

        private Expression ParsePostfixUnaryOperationExpression()
        {
            var term = ParseAdditionExpression();

            if (_currentToken.TokenType == MicroScriptTokenType.IncrementOperator || 
                _currentToken.TokenType == MicroScriptTokenType.ExistsOperator)
            {
                var op = _currentToken.TokenType;
                NextToken();
                return new UnaryOperatorExpression(op, term) { IsPostfix = true };                
            }
            else
            {
                return term;
            }
        }

        private Expression ParseAdditionExpression()
        {
            Expression term = ParseTerm();

            while (_currentToken.TokenType == MicroScriptTokenType.AdditionOperator ||
                _currentToken.TokenType == MicroScriptTokenType.MinusOperator)
            {
                var t = _currentToken.TokenType;

                NextToken();

                term = ParseCall(new BinaryOperatorExpression(term, t, ParseTerm()));
            }

            return term;
        }

        public Expression ParseTerm()
        {
            var memberExp = ParseMemberExpression();

            if (_currentToken.TokenType == MicroScriptTokenType.MultiplicationOperator ||
                _currentToken.TokenType == MicroScriptTokenType.DivisionOperator)
            {
                var op = _currentToken.TokenType;
                NextToken();
                return new BinaryOperatorExpression(memberExp, op, ParseTerm());
            }
            else
            {
                return memberExp;
            }
        }

        public Expression ParseMemberExpression()
        {
            Expression factor = ParseFactor();

            while (_currentToken.TokenType == MicroScriptTokenType.MemberOperator)
            {
                NextToken();

                Expression exp;

                switch (_currentToken.TokenType)
                {
                    case MicroScriptTokenType.Identifier:
                        exp = new IdentifierExpression(_currentToken.Lexeme);
                        NextToken();
                        break;

                    case MicroScriptTokenType.String:
                        exp = ParseStringExpression();
                        break;

                    case MicroScriptTokenType.LeftBrace:
                        NextToken();
                        exp = new DynamicMemberExpression(ParseExpression());
                        Match(MicroScriptTokenType.RightBrace);
                        break;

                    default:
                        throw new MicroScriptParserException(_currentToken);
                }                

                factor = ParseCall(new BinaryOperatorExpression(factor, MicroScriptTokenType.MemberOperator, exp));
            }

            return factor;
        }

        public Expression ParseFactor()
        {
            Expression exp;
            switch (_currentToken.TokenType)
            {
                case MicroScriptTokenType.LeftBrace:
                    exp = ParseObjectExpression();
                    break;

                case MicroScriptTokenType.LeftBracket:
                    exp = ParseArrayExpression();
                    break;

                case MicroScriptTokenType.LeftParenthesis:
                    NextToken();
                    exp = ParseExpression();
                    Match(MicroScriptTokenType.RightParenthesis);
                    break;

                case MicroScriptTokenType.String:
                    exp = ParseStringExpression();
                    break;

                case MicroScriptTokenType.Number:
                    exp = ParseNumberExpression();
                    break;

                case MicroScriptTokenType.Identifier:
                    exp = ParseIdentifierExpression();
                    break;

                case MicroScriptTokenType.funKeyword:
                    exp = ParseFunctionExpression();
                    break;

                case MicroScriptTokenType.forKeyword:
                    exp = ParseForExpression();
                    break;

                case MicroScriptTokenType.retKeyword:
                    exp = ParsePrefixUnaryOperatorExpression();
                    break;

                case MicroScriptTokenType.NotOperator:
                    exp = ParsePrefixUnaryOperatorExpression();
                    break;

                case MicroScriptTokenType.trueKeyword:
                    exp = new BooleanExpression(true);
                    NextToken();
                    break;

                case MicroScriptTokenType.falseKeyword:
                    exp = new BooleanExpression(false);
                    NextToken();
                    break;

                case MicroScriptTokenType.ifKeyword:
                    exp = ParseIfExpression();
                    break;

                case MicroScriptTokenType.LoadScriptOperator:
                    exp = ParseLoadScriptExpression();
                    break;

                case MicroScriptTokenType.LoadLibraryOperator:
                    exp = ParseLoadLibraryExpression();
                    break;

                default:
                    throw new MicroScriptParserException(_currentToken);
            }

            switch (_currentToken.TokenType)
            {
                case MicroScriptTokenType.LeftBracket:
                    if (exp is ArrayExpression)
                    {
                        break;
                    }

                    NextToken();
                    var key = ParseExpression();
                    Match(MicroScriptTokenType.RightBracket);
                    exp = new ArrayAccessExpression(exp, key);
                    break;                
            }


            return ParseCall(exp);
        }

        public Expression ParseCall(Expression exp)
        {
            switch (_currentToken.TokenType)
            {
                case MicroScriptTokenType.LeftParenthesis:
                    NextToken();
                    if (_currentToken.TokenType == MicroScriptTokenType.RightParenthesis)
                    {
                        NextToken();
                        return new CallExpression(exp);
                    }
                    else
                    {
                        var args = ParseTuple();
                        Match(MicroScriptTokenType.RightParenthesis);
                        return new CallExpression(exp, args);
                    }

                default:
                    return exp;
            }
        }

        public UnaryOperatorExpression ParsePrefixUnaryOperatorExpression()
        {
            var t = _currentToken.TokenType;
            NextToken();
            return new UnaryOperatorExpression(t, ParseExpression());
        }

        private Expression ParseCondition()
        {
            Match(MicroScriptTokenType.LeftParenthesis);
            var condition = ParseExpression();
            Match(MicroScriptTokenType.RightParenthesis);
            return condition;
        }

        public ControlFlowExpression ParseControlFlowExpression()
        {
            var t = _currentToken.TokenType;
            NextToken();
            Match(MicroScriptTokenType.LeftParenthesis);
            var condition = ParseExpression();
            Match(MicroScriptTokenType.RightParenthesis);
            var body = ParseBlock();

            return new ControlFlowExpression(t, condition, body);
        }

        public IfExpression ParseIfExpression()
        {
            NextToken();
            var condition = ParseCondition();
            var body = ParseBlock();
            List<Expression> elseBody = null;
            if (_currentToken.TokenType == MicroScriptTokenType.elseKeyword)
            {
                NextToken();
                elseBody = ParseBlock();
            }
            return new IfExpression(condition, body, elseBody);
        }

        public ForExpression ParseForExpression()
        {
            NextToken();
            Match(MicroScriptTokenType.LeftParenthesis);
            var element = ParseIdentifierExpression();            
            Match(MicroScriptTokenType.inKeyword);
            var collection = ParseExpression();
            Match(MicroScriptTokenType.RightParenthesis);
            var body = ParseBlock();
            return new ForExpression(collection, element, body);

        }

        private List<Expression> ParseTuple()
        {
            var tuple = new List<Expression>();

            while (true)
            {
                tuple.Add(ParseExpression());

                if (_currentToken.TokenType == MicroScriptTokenType.Comma)
                {
                    NextToken();
                }
                else
                {
                    return tuple;
                }
            }
        }

        private List<Expression> ParseBlock(bool requireSingleExpEos = true)
        {
            var statements = new List<Expression>();

            if (_currentToken.TokenType == MicroScriptTokenType.LeftBrace)
            {
                NextToken();

                while (_currentToken.TokenType != MicroScriptTokenType.RightBrace)
                {
                    statements.Add(ParseStatement());
                }

                NextToken();
            }
            else
            {
                statements.Add(ParseStatement(requireSingleExpEos));

                //if (requireSingleExpEos)
                //{
                //    Match(MicroScriptTokenType.EndOfStatement);
                //}
            }

            return statements;
        }

        private LoadScriptExpression ParseLoadScriptExpression()
        {
            NextToken();
            return new LoadScriptExpression(ParseExpression());
        }

        private LoadLibraryExpression ParseLoadLibraryExpression()
        {
            NextToken();
            return new LoadLibraryExpression(ParseExpression());
        }

        private Expression ParseStatement(bool requireEos = true)
        {
            var exp = ParseExpression();

            if (requireEos &&
                !(exp is IfExpression) &&
                !(exp is ForExpression))
            {
                Match(MicroScriptTokenType.EndOfStatement);
            }

            return exp;
        }

        public List<Expression> Parse()
        {
            var expressionSequence = new List<Expression>();
            NextToken();

            var statements = new StatementSequence();

            while (_currentToken.Lexeme != null)
            {
                expressionSequence.Add(ParseStatement());
            }

            return expressionSequence;
        }
    }
}
