using System;
using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;
using PhpVH.LexicalAnalysis;

namespace PhpVH.Tests.LexicalAnalysis
{
    public static class LexerAssert
    {
        public static void IsEmpty(Lexer lexer)
        {
            CollectionAssert.AreEqual(new List<Token>(), lexer.GetTokens());
        }
    }

    public class Pairs<TKey, TValue> : List<KeyValuePair<TKey, TValue>>
    {
        public void Add(TKey key, TValue value)
        {
            Add(new KeyValuePair<TKey, TValue>(key, value));
        }
    }

    public class TokenPairs : Pairs<TokenType, string> { }

    public static class TokenAssert
    {
        public static void IsValid(TokenPairs pairs)
        {
            var text = string.Join("", pairs.Select(pair => pair.Value).ToArray());
            var lexer = new Lexer(text);
            int index = 0;
            var expected = pairs.Select(pair =>
            {
                var token = new Token(pair.Key, pair.Value, index);
                index += pair.Value.Length;
                return token;
            });
            List<Token> actual = lexer.GetTokens();
            CollectionAssert.AreEqual(expected, actual);
        }

        public static void IsValid(TokenType expectedTokenType, string actualText)
        {
            IsValid(new TokenPairs {
               { TokenType.OpenTag, "<?" },
               { expectedTokenType, actualText },
               { TokenType.CloseTag, "?>" }
            });
        }

        public static void AreHtmlTokens(string[] texts)
        {
            foreach (string text in texts)
                IsValid(new TokenPairs { { TokenType.Html, text } });
        }
    }

    [TestFixture]
    public class LexerTest
    {
        [Test]
        public void Default_Constructor_Returns_Empty_List()
        {
            var lexer = new Lexer();
            LexerAssert.IsEmpty(lexer);
        }

        [Test]
        public void Empty_String_Returns_Empty_List()
        {
            var lexer = new Lexer("");
            LexerAssert.IsEmpty(lexer);
        }

        [Test]
        public void Simple_Open_Tag_Returns_OpenTag_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" }
            });
        }

        [Test]
        public void Standard_Open_Tag_Returns_OpenTag_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?php" }
            });
        }

        [Test]
        public void Simple_Open_And_Close_Tags_Returns_OpenTag_And_CloseTag_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test]
        public void Standard_Open_And_Close_Tags_Returns_OpenTag_And_CloseTag_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?php" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test]
        public void Plus_Sign_Returns_AdditionOperator_Token()
        {
            TokenAssert.IsValid(TokenType.AdditionOperator, "+");
        }

        [Test]
        public void Ampersand_Returns_Ampersand_Token()
        {
            TokenAssert.IsValid(TokenType.Ampersand, "&");
        }

        [Test]
        public void Two_Ampersands_Returns_AndOperator_Token()
        {
            TokenAssert.IsValid(TokenType.AndOperator, "&&");
        }

        [Test]
        public void Equals_Sign_Returns_AssignmentOperator_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.WhiteSpace, " " },
                { TokenType.AssignmentOperator, "=" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test]
        public void Two_Backticks_Returns_BacktickString_Token()
        {
            TokenAssert.IsValid(TokenType.BacktickString, "``");
        }

        [Test]
        public void Comma_Returns_Comma_Token()
        {
            TokenAssert.IsValid(TokenType.Comma, ",");
        }

        [Test]
        public void Two_Slashes_Returns_Comment_Token()
        {
            TokenAssert.IsValid(TokenType.Comment, "//");
        }

        [Test]
        public void Three_Slashes_Returns_Comment_Token()
        {
            TokenAssert.IsValid(TokenType.Comment, "///");
        }

        [Test]
        public void Star_Slash_Returns_Comment_Token()
        {
            TokenAssert.IsValid(TokenType.Comment, "/* comment */");
        }

        [Test]
        public void Tilde_Returns_ComplementOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ComplementOperator, "~");
        }

        [Test]
        public void Period_Equals_Returns_ConcatEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ConcatEqualOperator, ".=");
        }

        [Test]
        public void Two_Minuses_Returns_Decrement_Operator_Token()
        {
            TokenAssert.IsValid(TokenType.DecrementOperator, "--");
        }

        [Test]
        public void Forward_Slash_Equals_Returns_DivisonEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.DivisionEqualOperator, "/=");
        }

        [Test]
        public void Forward_Slash_Returns_DivisonOperator_Token()
        {
            TokenAssert.IsValid(TokenType.DivisionOperator, "/");
        }

        // TODO: Test EndOfFile

        [Test]
        public void Semicolon_Returns_EndOfStatement_Token()
        {
            TokenAssert.IsValid(TokenType.EndOfStatement, ";");
        }

        [Test]
        public void Equals_Equals_Returns_EqualityOperator_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.WhiteSpace, " " },
                { TokenType.EqualityOperator, "==" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test]
        public void At_Symbol_Returns_ErrorSuppressor_Token()
        {
            TokenAssert.IsValid(TokenType.ErrorSuppressor, "@");
        }

        [Test]
        public void Greater_Than_Returns_GreaterThanOperator_Token()
        {
            TokenAssert.IsValid(TokenType.GreaterThanOperator, ">");
        }

        [Test]
        public void Greater_Than_Equals_Returns_GreaterThanOrEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.GreaterThanOrEqualOperator, ">=");
        }

        // TODO: Test HereDoc

        [Test]
        public void All_Tokens_Not_In_PHP_Open_Close_Tags_Returns_Html_Token()
        {
            TokenAssert.AreHtmlTokens(new string[] {
                "+", "&", "&&", "=", "``", ",", "//", "///", "/* comment */", "~",
                ".=", "--", "/=", "/", ";", "==", "@", ">", ">=", "===", "-", "<?"
            });
        }

        [Test]
        public void wtf()
        {
            TokenAssert.IsValid(new TokenPairs { { TokenType.Html, "<?" } });
        }

        [Test]
        public void Equals_Equals_Equals_Returns_IdenticalOperator_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.WhiteSpace, " " },
                { TokenType.IdenticalOperator, "===" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test]
        public void Minus_Sign_Returns_SubtractionOperator_Token()
        {
            TokenAssert.IsValid(TokenType.SubtractionOperator, "-");
        }

        [Test]
        public void Print_Addition_Returns_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
               { TokenType.OpenTag, "<?php" },
               { TokenType.WhiteSpace, " " },
               { TokenType.Identifier, "print" },
               { TokenType.LeftParenthesis, "(" },
               { TokenType.Number, "1" },
               { TokenType.AdditionOperator, "+" },
               { TokenType.Number, "2" },
               { TokenType.RightParenthesis, ")" },
               { TokenType.WhiteSpace, " " },
               { TokenType.CloseTag, "?>" }
            });
        }

        [Test]
        public void Basic_Ternary_Expression_Returns_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.Identifier, "print" },
                { TokenType.LeftParenthesis, "(" },
                { TokenType.LeftParenthesis, "(" },
                { TokenType.Identifier, "true" },
                { TokenType.OrOperator, "||" },
                { TokenType.Identifier, "false" },
                { TokenType.RightParenthesis, ")" },
                { TokenType.TernaryOperator, "?" },
                { TokenType.String, "'yay'" },
                { TokenType.TernaryOperator, ":" },
                { TokenType.String, "'nay'" },
                { TokenType.RightParenthesis, ")" },
                { TokenType.EndOfStatement, ";" },
                { TokenType.CloseTag, "?>" }
            });
        }
    }
}
