using System;
using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;
using PhpVH.LexicalAnalysis;

namespace PhpVH.Tests.Unit.LexicalAnalysis
{
    [TestFixture]
    public partial class LexerTest
    {
        [Test, Category("PhpLexer")]
        public void Default_Constructor_Returns_Empty_List()
        {
            var lexer = new Lexer();
            LexerAssert.IsEmpty(lexer);
        }

        [Test, Category("PhpLexer")]
        public void Empty_String_Returns_Empty_List()
        {
            var lexer = new Lexer("");
            LexerAssert.IsEmpty(lexer);
        }

        [Test, Category("PhpLexer")]
        public void Simple_Open_Tag_Returns_OpenTag_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Standard_Open_Tag_Returns_OpenTag_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?php" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Simple_Open_And_Close_Tags_Returns_OpenTag_And_CloseTag_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Standard_Open_And_Close_Tags_Returns_OpenTag_And_CloseTag_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?php" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void LessThan_QuestionMark_phz_Returns_OpenTag_And_Unknown_Tokens()
        {
            var lexer = new Lexer("<?phz");
            var tokens = lexer.GetTokens();
            CollectionAssert.AreEqual(new List<Token>
            {
                new Token(TokenType.OpenTag, "<?", 0),
                new Token(TokenType.Unknown, "phz", 2)
            }, tokens);
        }

        [Test, Category("PhpLexer")]
        public void Simple_Open_Tag_And_Echo_Returns_OpenTag_And_Echo_Tokens()
        {
            var lexer = new Lexer("<?echo(\"test\")");
            var tokens = lexer.GetTokens();
            CollectionAssert.AreEqual(new List<Token>
            {
                new Token(TokenType.OpenTag, "<?", 0),
                new Token(TokenType.Identifier, "echo", 2),
                new Token(TokenType.LeftParenthesis, "(", 6),
                new Token(TokenType.String, "\"test\"", 7),
                new Token(TokenType.RightParenthesis, ")", 13)
            }, tokens);
        }

        [Test, Category("PhpLexer")]
        public void LessThan_QuestionMark_Equals_Returns_OpenTagWithEcho_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTagWithEcho, "<?=" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Asp_Open_Tag_Returns_OpenTag_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<%" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Asp_Open_Tag_Equals_Returns_OpenTagWithEcho_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTagWithEcho, "<%=" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Asp_Open_And_Close_Tags_Returns_OpenTag_And_CloseTag_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<%" },
                { TokenType.CloseTag, "%>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Simple_Open_And_Close_Tags_With_Variable_Returns_OpenTagWithEcho_And_Variable_And_CloseTag_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTagWithEcho, "<%=" },
                { TokenType.Variable, "$variable" },
                { TokenType.CloseTag, "%>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Bad_Open_Tag_Returns_Html_Token()
        {
            TokenAssert.IsValid(new TokenPairs
            {
                { TokenType.Html, "<=$variable?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void First_Character_Isnt_Less_Than_Returns_Html_Token()
        {
            TokenAssert.IsValid(new TokenPairs
            {
                { TokenType.Html, "echo(\"test\");" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Plus_Sign_Returns_AdditionOperator_Token()
        {
            TokenAssert.IsValid(TokenType.AdditionOperator, "+");
        }

        [Test, Category("PhpLexer")]
        public void Ampersand_Returns_Ampersand_Token()
        {
            TokenAssert.IsValid(TokenType.Ampersand, "&");
        }

        [Test, Category("PhpLexer")]
        public void Two_Ampersands_Returns_AndOperator_Token()
        {
            TokenAssert.IsValid(TokenType.AndOperator, "&&");
        }

        [Test, Category("PhpLexer")]
        public void Equals_Sign_Returns_AssignmentOperator_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.WhiteSpace, " " },
                { TokenType.AssignmentOperator, "=" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Two_Backticks_Returns_BacktickString_Token()
        {
            TokenAssert.IsValid(TokenType.BacktickString, "``");
        }

        [Test, Category("PhpLexer")]
        public void Comma_Returns_Comma_Token()
        {
            TokenAssert.IsValid(TokenType.Comma, ",");
        }

        [Test, Category("PhpLexer")]
        public void Two_Slashes_Returns_Comment_Token()
        {
            TokenAssert.IsValid(TokenType.Comment, "//");
        }

        [Test, Category("PhpLexer")]
        public void Three_Slashes_Returns_Comment_Token()
        {
            TokenAssert.IsValid(TokenType.Comment, "///");
        }

        [Test, Category("PhpLexer")]
        public void Star_Slash_Returns_Comment_Token()
        {
            TokenAssert.IsValid(TokenType.Comment, "/* comment */");
        }

        [Test, Category("PhpLexer")]
        public void Star_Slash_No_Close_Tag_Returns_Comment_Token()
        {
            var lexer = new Lexer("<?/*");
            var tokens = lexer.GetTokens();
            CollectionAssert.AreEqual(new List<Token>
            {
                new Token(TokenType.OpenTag, "<?", 0),
                new Token(TokenType.Comment, "/*", 2)
            }, tokens);
        }

        [Test, Category("PhpLexer")]
        public void Two_Slashes_Newline_Returns_Comment_Token()
        {
            var lexer = new Lexer("<?//\nfunct");
            var tokens = lexer.GetTokens();
            CollectionAssert.AreEqual(new List<Token>
            {
                new Token(TokenType.OpenTag, "<?", 0),
                new Token(TokenType.Comment, "//", 2),
                new Token(TokenType.WhiteSpace, "\n", 4),
                new Token(TokenType.Unknown, "funct", 5)
            }, tokens);
        }

        [Test, Category("PhpLexer")]
        public void Two_Slashes_No_Close_Tag_Returns_Comment_Token()
        {
            var lexer = new Lexer("<?//");
            var tokens = lexer.GetTokens();
            CollectionAssert.AreEqual(new List<Token>
            {
                new Token(TokenType.OpenTag, "<?", 0),
                new Token(TokenType.Comment, "//", 2)
            }, tokens);
        }

        [Test, Category("PhpLexer")]
        public void Tilde_Returns_ComplementOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ComplementOperator, "~");
        }

        [Test, Category("PhpLexer")]
        public void Period_Equals_Returns_ConcatEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ConcatEqualOperator, ".=");
        }

        [Test, Category("PhpLexer")]
        public void Two_Minuses_Returns_Decrement_Operator_Token()
        {
            TokenAssert.IsValid(TokenType.DecrementOperator, "--");
        }

        [Test, Category("PhpLexer")]
        public void Forward_Slash_Equals_Returns_DivisonEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.DivisionEqualOperator, "/=");
        }

        [Test, Category("PhpLexer")]
        public void Forward_Slash_Returns_DivisonOperator_Token()
        {
            TokenAssert.IsValid(TokenType.DivisionOperator, "/");
        }

        // TODO: Test EndOfFile

        [Test, Category("PhpLexer")]
        public void Semicolon_Returns_EndOfStatement_Token()
        {
            TokenAssert.IsValid(TokenType.EndOfStatement, ";");
        }

        [Test, Category("PhpLexer")]
        public void Equals_Equals_Returns_EqualityOperator_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.WhiteSpace, " " },
                { TokenType.EqualityOperator, "==" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void At_Symbol_Returns_ErrorSuppressor_Token()
        {
            TokenAssert.IsValid(TokenType.ErrorSuppressor, "@");
        }

        [Test, Category("PhpLexer")]
        public void Greater_Than_Returns_GreaterThanOperator_Token()
        {
            TokenAssert.IsValid(TokenType.GreaterThanOperator, ">");
        }

        [Test, Category("PhpLexer")]
        public void Greater_Than_Equals_Returns_GreaterThanOrEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.GreaterThanOrEqualOperator, ">=");
        }

        [Test, Category("PhpLexer")]
        public void Three_Less_Thans_Returns_HereDocString_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.HereDocString, "<<<EOT\nEOT" },
                { TokenType.EndOfStatement, ";" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void HereDoc_With_Other_Tokens_Returns_HereDocString_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.HereDocString, "<<<EOT\n//@\n'test'\"value\"<<<\nEOT" },
                { TokenType.WhiteSpace, "\n" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void All_Tokens_Not_In_PHP_Open_Close_Tags_Returns_Html_Token()
        {
            TokenAssert.AreHtmlTokens(new string[] {
                "+", "&", "&&", "=", "``", ",", "//", "///", "/* comment */", "~",
                ".=", "--", "/=", "/", ";", "==", "@", ">", ">=", "===", "-"
            });
        }

        [Test, Category("PhpLexer")]
        public void Equals_Equals_Equals_Returns_IdenticalOperator_Token()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.WhiteSpace, " " },
                { TokenType.IdenticalOperator, "===" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Word_test_Returns_Identifier_Token()
        {
            TokenAssert.IsValid(TokenType.Identifier, "test");
        }

        [Test, Category("PhpLexer")]
        public void PlusSign_PlusSign_Returns_IncrementOperator_Token()
        {
            TokenAssert.IsValid(TokenType.IncrementOperator, "++");
        }

        [Test, Category("PhpLexer")]
        public void Left_Brace_Returns_LeftBrace_Token()
        {
            TokenAssert.IsValid(TokenType.LeftBrace, "{");
        }

        [Test, Category("PhpLexer")]
        public void Left_Bracket_Returns_LeftBracket_Token()
        {
            TokenAssert.IsValid(TokenType.LeftBracket, "[");
        }

        [Test, Category("PhpLexer")]
        public void Left_Parenthesis_Returns_LeftParenthesis_Token()
        {
            TokenAssert.IsValid(TokenType.LeftParenthesis, "(");
        }

        [Test, Category("PhpLexer")]
        public void Less_Than_Returns_LessThanOperator_Token()
        {
            TokenAssert.IsValid(TokenType.LessThanOperator, "<");
        }

        [Test, Category("PhpLexer")]
        public void Less_Than_Equals_Returns_LessThanOrEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.LessThanOrEqualOperator, "<=");
        }

        [Test, Category("PhpLexer")]
        public void Minus_Equals_Returns_MinusEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.MinusEqualOperator, "-=");
        }

        [Test, Category("PhpLexer")]
        public void Modulus_Equals_Returns_ModulusEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ModulusEqualOperator, "%=");
        }

        [Test, Category("PhpLexer")]
        public void Modulus_Returns_ModulusOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ModulusOperator, "%");
        }

        [Test, Category("PhpLexer")]
        public void Star_Equals_Returns_MultiplicationEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.MultiplicationEqualOperator, "*=");
        }

        [Test, Category("PhpLexer")]
        public void Star_Returns_MultiplicationOperator_Token()
        {
            TokenAssert.IsValid(TokenType.MultiplicationOperator, "*");
        }

        [Test, Category("PhpLexer")]
        public void Two_Backslashes_Returns_Namespace_Token()
        {
            TokenAssert.IsValid(TokenType.Namespace, "\\");
        }

        [Test, Category("PhpLexer")]
        public void Exclamation_Equals_Returns_NotEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.NotEqualOperator, "!=");
        }

        [Test, Category("PhpLexer")]
        public void Exclamation_Equals_Equals_Returns_NotIdenticalOperator_Token()
        {
            TokenAssert.IsValid(TokenType.NotIdenticalOperator, "!==");
        }

        [Test, Category("PhpLexer")]
        public void Exclamation_Returns_NotOperator_Token()
        {
            TokenAssert.IsValid(TokenType.NotOperator, "!");
        }

        [Test, Category("PhpLexer")]
        public void One_Two_Three_Four_Returns_Number_Token()
        {
            TokenAssert.IsValid(TokenType.Number, "1234");
        }

        [Test, Category("PhpLexer"), Ignore]
        public void Negative_One_Two_Three_Four_Returns_Number_Token()
        {
            TokenAssert.IsValid(TokenType.Number, "-1234");
        }

        [Test, Category("PhpLexer")]
        public void Dash_Greater_Than_Returns_ObjectOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ObjectOperator, "->");
        }

        [Test, Category("PhpLexer")]
        public void Pipe_Equals_Returns_OrEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.OrEqualOperator, "|=");
        }

        [Test, Category("PhpLexer")]
        public void Two_Pipes_Returns_OrOperator_Token()
        {
            TokenAssert.IsValid(TokenType.OrOperator, "||");
        }

        [Test, Category("PhpLexer")]
        public void Pipe_Returns_OrOperator_Token()
        {
            TokenAssert.IsValid(TokenType.OrOperator, "|");
        }

        [Test, Category("PhpLexer")]
        public void Plus_Sign_Equals_Returns_PlusEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.PlusEqualOperator, "+=");
        }

        [Test, Category("PhpLexer")]
        public void Right_Brace_Returns_RightBrace_Token()
        {
            TokenAssert.IsValid(TokenType.RightBrace, "}");
        }

        [Test, Category("PhpLexer")]
        public void Right_Bracket_Returns_RightBracket_Token()
        {
            TokenAssert.IsValid(TokenType.RightBracket, "]");
        }

        [Test, Category("PhpLexer")]
        public void Right_Parenthesis_Returns_RightParenthesis_Token()
        {
            TokenAssert.IsValid(TokenType.RightParenthesis, ")");
        }

        [Test, Category("PhpLexer")]
        public void Two_Semicolons_Returns_ScopeResolutionOperator_Token()
        {
            TokenAssert.IsValid(TokenType.ScopeResolutionOperator, "::");
        }

        [Test, Category("PhpLexer")]
        public void Two_Less_Thans_Returns_ShiftLeft_Token()
        {
            TokenAssert.IsValid(TokenType.ShiftLeft, "<<");
        }

        [Test, Category("PhpLexer")]
        public void Two_Greater_Thans_Returns_ShiftRight_Token()
        {
            TokenAssert.IsValid(TokenType.ShiftRight, ">>");
        }

        [Test, Category("PhpLexer")]
        public void Double_Quoted_Returns_String_Token()
        {
            TokenAssert.IsValid(TokenType.String, "\"value\"");
        }

        [Test, Category("PhpLexer")]
        public void Single_Quoted_Returns_String_Token()
        {
            TokenAssert.IsValid(TokenType.String, "'value'");
        }

        [Test, Category("PhpLexer")]
        public void Period_Returns_StringConcatOperator_Token()
        {
            TokenAssert.IsValid(TokenType.StringConcatOperator, ".");
        }

        [Test, Category("PhpLexer")]
        public void Minus_Sign_Returns_SubtractionOperator_Token()
        {
            TokenAssert.IsValid(TokenType.SubtractionOperator, "-");
        }

        [Test, Category("PhpLexer")]
        public void Question_Mark_Returns_TernaryOperator_Token()
        {
            TokenAssert.IsValid(TokenType.TernaryOperator, "?");
        }

        [Test, Category("PhpLexer"), Ignore]
        public void Returns_Unknown_Token()
        {
            TokenAssert.IsValid(TokenType.Unknown, "");
        }

        [Test, Category("PhpLexer")]
        public void Dollar_Sign_Word_Returns_Variable_Token()
        {
            TokenAssert.IsValid(TokenType.Variable, "$variable");
        }

        [Test, Category("PhpLexer"), Ignore]
        public void Returns_VariableVariable_Token()
        {
            TokenAssert.IsValid(TokenType.VariableVariable, "");
        }

        [Test, Category("PhpLexer")]
        public void Space_Returns_WhiteSpace_Token()
        {
            TokenAssert.IsValid(TokenType.WhiteSpace, " ");
        }

        [Test, Category("PhpLexer")]
        public void Tab_Returns_WhiteSpace_Token()
        {
            TokenAssert.IsValid(TokenType.WhiteSpace, "\t");
        }

        [Test, Category("PhpLexer")]
        public void Backslash_N_Returns_WhiteSpace_Token()
        {
            TokenAssert.IsValid(TokenType.WhiteSpace, "\n");
        }

        [Test, Category("PhpLexer")]
        public void Simple_Open_And_Close_Tags_Around_Backslash_R_Backslash_N_Returns_WhiteSpace_Token()
        {
            TokenAssert.IsValid(new TokenPairs
            {
                {TokenType.OpenTag, "<?"},
                {TokenType.WhiteSpace, "\r"},
                {TokenType.WhiteSpace, "\r"},
                {TokenType.CloseTag, "?>"}
            });
        }

        [Test, Category("PhpLexer")]
        public void Up_Carrot_Equals_Returns_XorEqualOperator_Token()
        {
            TokenAssert.IsValid(TokenType.XorEqualOperator, "^=");
        }

        [Test, Category("PhpLexer")]
        public void Up_Carrot_Returns_XorOperator_Token()
        {
            TokenAssert.IsValid(TokenType.XorOperator, "^");
        }

        [Test, Category("PhpLexer")]
        public void Print_Addition_Returns_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
               { TokenType.OpenTag, "<?php" },
               { TokenType.WhiteSpace, " " },
               { TokenType.Identifier, "print" },
               { TokenType.LeftParenthesis, "(" },
               { TokenType.Number, "1" },
               { TokenType.AdditionOperator, "+" },
               { TokenType.Number, "2" },
               { TokenType.RightParenthesis, ")" },
               { TokenType.WhiteSpace, " " },
               { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer")]
        public void Basic_Ternary_Expression_Returns_Tokens()
        {
            TokenAssert.IsValid(new TokenPairs {
                { TokenType.OpenTag, "<?" },
                { TokenType.Identifier, "print" },
                { TokenType.LeftParenthesis, "(" },
                { TokenType.LeftParenthesis, "(" },
                { TokenType.Identifier, "true" },
                { TokenType.OrOperator, "||" },
                { TokenType.Identifier, "false" },
                { TokenType.RightParenthesis, ")" },
                { TokenType.TernaryOperator, "?" },
                { TokenType.String, "'yay'" },
                { TokenType.TernaryOperator, ":" },
                { TokenType.String, "'nay'" },
                { TokenType.RightParenthesis, ")" },
                { TokenType.EndOfStatement, ";" },
                { TokenType.CloseTag, "?>" }
            });
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void Else_Returns_ElseKeyword_Token()
        {
            TokenAssert.IsValid(TokenType.elseKeyword, "else");
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void ElseIf_Returns_ElseIfKeyword_Token()
        {
            TokenAssert.IsValid(TokenType.elseifKeyword, "elseif");
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void E_Returns_Identifier_Token()
        {
            TokenAssert.IsValid(TokenType.Identifier, "e");
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void El_Returns_Identifier_Token()
        {
            TokenAssert.IsValid(TokenType.Identifier, "el");
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void Els_Returns_Identifier_Token()
        {
            TokenAssert.IsValid(TokenType.Identifier, "els");
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void ElseI_Returns_Identifier_Token()
        {
            TokenAssert.IsValid(TokenType.Identifier, "elsei");
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void Elsex_Returns_Identifier_Token()
        {
            TokenAssert.IsValid(TokenType.Identifier, "elsex");
        }

        [Test, Category("PhpLexer"), Category("MaximalMunch")]
        public void ElseIfx_Returns_Identifier_Token()
        {
            TokenAssert.IsValid(TokenType.Identifier, "elseifx");
        }
    }
}
