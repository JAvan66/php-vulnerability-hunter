using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using PhpVH.LexicalAnalysis;

namespace PhpVH.CodeCoverage
{
    public class Annotator
    {
        public FileInfo AnnotationFile { get; set; }

        public Dictionary<string, int> AnnotationIndexes { get; private set; }

        public AnnotationTable AnnotationTable { get; private set; }

        public Annotator()
        {
            AnnotationIndexes = new Dictionary<string, int>();
            AnnotationTable = new AnnotationTable();
        }

        public string AnnotateCode(string file, string php, Token[] tokens)
        {
            lock (AnnotationIndexes)
            {
                AnnotationIndexes.Add(file, 0);
            }

            lock (AnnotationIndexes)
            {
                AnnotationTable.Add(file);
            }

            for (int i = tokens.Length - 1; i >= 0; i--)
            {
                if (tokens[i].TokenType == TokenType.LeftBrace)
                {
                    php = AnnotateBlock(file, php,
                        tokens, i, Program.Config.CodeCoverageReport == 1);
                }
            }

            var open = tokens.FirstOrDefault(x => x.TokenType == TokenType.OpenTag);

            if (open.Lexeme != null)
            {
                php = Annotate(file, php, open.Index + open.Lexeme.Length);
            }
            else
            {
                var tmp = Annotate(file, "<?php  ?>", 6);
                php = tmp + php;
            }

            return php;
        }

        public string Annotate(string file, string code, int index)
        {
            int x;

            lock (AnnotationIndexes)
            {
                x = AnnotationIndexes[file]++;
            }

            lock (AnnotationTable)
            {
                AnnotationTable[file].Add(new Annotation(x, index));
            }

            code = code.Insert(
                index,
                string.Format("\r\nAnnotation(\"{0}_{1}\");\r\n",
                file.Replace("\\", "\\\\"), x));

            return code;
        }

        public string AnnotateBlock(string File, string Code, Token[] Tokens,
            int TokenIndex, bool FunctionsOnly)
        {
            if (Tokens[TokenIndex - 1].TokenType != TokenType.RightParenthesis &&
                Tokens[TokenIndex - 1].TokenType != TokenType.Keyword)
                return Code;

            for (int i = TokenIndex; i >= 0; i--)
            {
                if (Tokens[i].TokenType == TokenType.Keyword)
                {
                    if (Tokens[i].Lexeme == "switch" ||
                        (FunctionsOnly && Tokens[i].Lexeme != "function"))
                        return Code;

                    break;
                }
            }

            Code = Annotate(File, Code, Tokens[TokenIndex].Index + 1);

            return Code;
        }

        public void Reset()
        {
            AnnotationFile.Delete();
        }
    }
}
